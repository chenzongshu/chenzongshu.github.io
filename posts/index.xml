<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on 蜗牛龙门阵</title>
    <link>chenzongshu.github.io/posts/</link>
    <description>Recent content in Posts on 蜗牛龙门阵</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-CN</language>
    <lastBuildDate>Fri, 05 Feb 2021 11:27:22 +0800</lastBuildDate><atom:link href="chenzongshu.github.io/posts/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Etcd源码分析</title>
      <link>chenzongshu.github.io/posts/etcd%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8B%E5%90%AF%E5%8A%A8%E7%AF%87/</link>
      <pubDate>Fri, 05 Feb 2021 11:27:22 +0800</pubDate>
      
      <guid>chenzongshu.github.io/posts/etcd%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8B%E5%90%AF%E5%8A%A8%E7%AF%87/</guid>
      <description>启动 启动从源码 /etcdmain/main.go 中的main函数开始
func Main() { checkSupportArch() // 检查系统是否支持 if len(os.Args) &amp;gt; 1 { // 获取入参 cmd := os.Args[1] // 获取启动命令 if covArgs := os.Getenv(&amp;quot;ETCDCOV_ARGS&amp;quot;); len(covArgs) &amp;gt; 0 { args := strings.Split(os.Getenv(&amp;quot;ETCDCOV_ARGS&amp;quot;), &amp;quot;\xe7\xcd&amp;quot;)[1:] rootCmd.SetArgs(args) cmd = &amp;quot;grpc-proxy&amp;quot; } switch cmd { case &amp;quot;gateway&amp;quot;, &amp;quot;grpc-proxy&amp;quot;: if err := rootCmd.Execute(); err != nil { fmt.Fprint(os.Stderr, err) os.Exit(1) } return } } startEtcdOrProxyV2() } 上面仔细去看，前面是根据命令行输入的第一个参数去启动不同的代码逻辑
后面的startEtcdOrProxyV2()则是启动etcd server的函数
命令行输入 我们来查看一下etcd命令的使用帮助:
$ ./etcd -help Usage: etcd [flags] Start an etcd server.</description>
    </item>
    
  </channel>
</rss>
